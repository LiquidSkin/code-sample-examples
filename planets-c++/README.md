# Planets C++ Example

This is a simple code sample that I wrote as an example for those who have never written a code sample before. See [my blog article on this topic](https://jayjaybillings.com/2018/01/31/what-does-a-good-code-sample-look-like/) for more information.

This sample computes the static gravitational potential of a configuration of celestial bodies. The example configuration is completely random and the answer is junk, but this should be sufficient for a code sample. The gravitational potential is computed by simple direct summation. This is not efficient for many bodies, but since this is a sample and the number of bodies are small, it is the best way to implement it.

This sample demonstrates:
* Use of classes
* Use of interfaces
* Use of templates classes from the STL (not the implementation of such)
* Input and output operations
* Unit testing
* Use of Doxygen for documentation
* Use of a basic Makefile (initially generated by Eclipse CDT)
* Use of Git for version control
* Use of Markdown and READMEs for out of source docs

There are several things that the example leaves out because it is just a sample, such as arguments parsing. For example, it hardwires the input file name to planetary-system.csv because, arguably, detailed argument parsing is out of the scope of a sample and a good topic for examination during an interview. ;-)

It is available under a 3-Clause BSD License, copyright UT-Battelle LLC. Queries may be sent to the author at jayjaybillings@gmail.com or on Twitter at @jayjaybillings.

## Build Instructions

For an in-source build, simply invoke make all at the bash prompt.
```bash
make all
```

The only required third-party library is BOOST, which is used for testing.

### Tests

Tests can be compiled and executed using
```bash
make test
```

### Cleaning

The build tree can be cleaned with
```bash
make clean
```

## Execution

Execute the code as follows using the example file "solar-system.csv" from the main directory (assuming in-source build):
```bash
./planets-c++
```

## Documentation

All classes are documented using Doxygen annotations. Only areas where new documentation are required are documented such that documentation may appear on subclasses, but may not appear on the operations those subclasses inherit since their functionality was described on the base class.
